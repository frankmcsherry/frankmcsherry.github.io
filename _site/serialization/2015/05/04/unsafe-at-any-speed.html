<!DOCTYPE html>
<html>

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width initial-scale=1">

  <title>Abomonation: terrifying serialization</title>
  <meta name="description" content="Today we’re going to look at a simple serialization library written in Rust. Simple and utterly terrifying.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://www.frankmcsherry.org/serialization/2015/05/04/unsafe-at-any-speed.html">
  <link rel="alternate" type="application/atom+xml" title="Frank McSherry" href="http://www.frankmcsherry.org/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Frank McSherry</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">Some Background</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Abomonation: terrifying serialization</h1>
    <p class="post-meta">May 4, 2015</p>
  </header>

  <article class="post-content">
    <p>Today we’re going to look at a simple serialization library written in Rust. Simple and utterly terrifying.</p>

<p>The library, Abomonation (typo intentional), uses Rust’s <code>unsafe</code> keyword in some interesting ways. The intent is that it is actually safe if you only deserialize binary data serialized by the library.</p>

<p>I should say that many of the things going on in here look a lot like what goes on in <a href="https://capnproto.org">CapnProto</a>. If you are serious about being a grown-up about things, I would absolutely look over there. Among other things, it has the advantage of not necessarily lowering your opinion of me, unlike this post.</p>

<h2 id="serialization-and-deserialization">Serialization and Deserialization</h2>

<p>Our goal is to write a pair of methods with the following signatures:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">encode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">typed</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">];</span></code></pre></div>

<p>That is, if you present a slice of data <code>&amp;[T]</code> we can populate a <code>Vec&lt;u8&gt;</code> with appropriate binary data. Similarly, if you provide us some binary data <code>&amp;[u8]</code>, we can interpret it as typed data <code>&amp;[T]</code> for you.</p>

<p>We aren’t going to do this by the end of the post, but we’ll have something pretty similar. These are the actual signatures at the moment (the implementations are at the end of the post; don’t read them yet!):</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">encode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Abomonation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">typed</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Abomonation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span></code></pre></div>

<p>There are important distinctions here, so let’s briefly think about what’s being said by the interfaces.</p>

<ol>
  <li>We are only going to be able to do this for <strong>some</strong> types <code>T</code>, those implementing <code>Abomonation</code>.
This makes sense, because some types are hard to serialize. The name doesn’t make sense. Yet.</li>
  <li>We are taking a <code>&amp;mut [u8]</code> rather than a <code>&amp;[u8]</code>. That’s weird. Why would we need exclusive access to the input data? Are we going to change the binary data we’ve received? (I’m so sorry.)</li>
  <li>We are returning a reference to a <code>Vec&lt;T&gt;</code>. Where did that <code>Vec&lt;T&gt;</code> come from and who owns it?
The <code>decode</code> function doesn’t take one as a parameter, and you (usually) don’t just get references to owned data out of nowhere.</li>
</ol>

<p>Well isn’t that just a big pile of mysterious language? Apparently we are going to do some things, and you should all be terrified.</p>

<h2 id="encoding-and-decoding-nice-data">Encoding and Decoding nice data</h2>

<p>Let’s start with some easy examples, ones that use the <code>unsafe</code> keyword but which we’ll pretty easily convince ourselves are really pretty friendly. We’ll get to learn a bit about how Rust manages its data under the covers, and maybe get our feet wet. What could go wrong?</p>

<p>The following function takes a slice of typed data and presents it back as a slice of binary data.</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="n">typed_to_bytes</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">slice</span><span class="o">::</span><span class="n">from_raw_parts</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="o">*</span><span class="kr">const</span> <span class="kt">u8</span><span class="p">,</span>
                               <span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="o">*</span> <span class="n">mem</span><span class="o">::</span><span class="n">size_of</span><span class="o">::&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">())</span>
<span class="p">}</span></code></pre></div>

<p>Notice the <code>unsafe</code> label on the function. This is because it uses the <code>from_raw_parts</code> method, which is itself unsafe (it doesn’t check to make sure that the underlying data look correct). In this case it is safe, because we only want to look at the binary data (not mutate it) and every byte is a valid <code>u8</code>.</p>

<p>I could choose to remove the <code>unsafe</code> label and put unsafe interally like so, declaring the method safe:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">typed_to_bytes</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span><span class="o">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">]</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">slice</span><span class="o">::</span><span class="n">from_raw_parts</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">as_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="o">*</span><span class="kr">const</span> <span class="kt">u8</span><span class="p">,</span>
                                   <span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="o">*</span> <span class="n">mem</span><span class="o">::</span><span class="n">size_of</span><span class="o">::&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>I have been warned this is bad, though, because reading a struct-padding byte is undefined behavior. This will not be the most irresponsible thing that happens in this post.</p>

<p>On the other end of the safety spectrum, I present:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="n">bytes_to_typed</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">slice</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">slice</span><span class="o">::</span><span class="n">from_raw_parts_mut</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">()</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="n">T</span><span class="p">,</span>
                                   <span class="n">slice</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="o">/</span> <span class="n">mem</span><span class="o">::</span><span class="n">size_of</span><span class="o">::&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">())</span>
<span class="p">}</span></code></pre></div>

<p>This not only exposes mutable slices, but permits any type at all. Imagine what would happen if <code>T</code> was <code>String</code>, for example: <code>String</code> owns its <code>[u8]</code> buffer and cointains a pointer to it. You would be able to dereference arbitrary places in memory! Danger!! Danger!! The <code>unsafe</code> label stays on for this one.</p>

<p>Imagine you just saw <code>bytes_to_typed</code> eat a goat. It is powerful, but the <code>unsafe</code> fence protects us. Just like in that movie with all those cautionary tales that I didn’t stay for the end of.</p>

<h3 id="you-said-nice-data">You said “nice data”</h3>

<p>These two methods work great if all you want to serialize are slices of primitive types. If you have a <code>&amp;[u64]</code> you can just transmute it over to a <code>&amp;[u8]</code> and write out the data. If you get a <code>&amp;[u8]</code> back you can (in good conscience) know that transmuting it to <code>&amp;[u64]</code> works well.</p>

<p>We are going to use the above two functions in our implementation of <code>encode</code> and <code>decode</code>, so let’s be brave and add the following sorts of implementations:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span> <span class="n">Abomonation</span> <span class="k">for</span> <span class="kt">u8</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Abomonation</span> <span class="k">for</span> <span class="kt">u16</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Abomonation</span> <span class="k">for</span> <span class="kt">u32</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">Abomonation</span> <span class="k">for</span> <span class="kt">u64</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">// lots of others ...</span></code></pre></div>

<p>Notice that these implementations don’t <em>do</em> anything, they just indicate that it is safe for <code>encode</code> and <code>decode</code> to transmute them around. In fact, <code>Abomonation</code> will have a few methods, but these types can just use the default implementations.</p>

<h2 id="the-abomonation-stirs-">The Abomonation stirs …</h2>

<p>Primitive types are neat and all, but we are serious people! What about things like tuples? Surely I should be able to transmute a <code>&amp;[(u64, i8)]</code> to binary and back, right? Yes, you should. But…</p>

<p>… it’s complicated. You see, we built this trait to reach beyond primitive types. Much further beyond.</p>

<p>Ok, let’s just write down this trait.</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">trait</span> <span class="n">Abomonation</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">entomb</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">_writer</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">exhume</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">,</span> <span class="n">_bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Wow, grim. In case <code>unsafe</code> wasn’t enough, I chose creepy method names. Creepy, but appropriate!</p>

<p>The two methods have the following intents:</p>

<ul>
  <li>
    <p><code>entomb</code>: having written <code>&amp;self</code> as binary, serialize any further data it might own.</p>
  </li>
  <li>
    <p><code>exhume</code>: having populated <code>&amp;mut self</code> with binary data, deserialize data it owned.</p>
  </li>
</ul>

<p>The reason this trait exists is because our method <code>encode(&amp;Vec&lt;T&gt;, &amp;mut Vec&lt;u8&gt;)</code> is just going to copy the contents of the typed vector into the binary vector. Seems harmless enough for the types implementing <code>Abomonation</code> so far, but we will use <code>entomb</code> to check with each <code>T</code> to see if they want to write any more. Similarly, <code>decode</code> uses <code>exhume</code> on each element to recover any owned data.</p>

<p>Wait, owned data? What? I mean, <code>u64</code> doesn’t own any data, so does it need to do anything? Nope!<br />
All those other primitive types don’t need to either. They can use the default empty implementation.</p>

<p>All those happy townsfolk, oblivious to what awaits…</p>

<p>We got this far because we needed to talk about tuples. Let’s see how we might implement the weirdly capable <code>Abomonation</code> for a pair of abomonable types.</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">:</span> <span class="n">Abomonation</span><span class="p">,</span> <span class="n">T2</span><span class="o">:</span> <span class="n">Abomonation</span><span class="o">&gt;</span> <span class="n">Abomonation</span> <span class="k">for</span> <span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">entomb</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">writer</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">entomb</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span> <span class="bp">self</span><span class="p">.</span><span class="mf">1.</span><span class="n">entomb</span><span class="p">(</span><span class="n">writer</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">exhume</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">,</span> <span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="bp">self</span><span class="p">.</span><span class="mf">0.</span><span class="n">exhume</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span> <span class="bp">self</span><span class="p">.</span><span class="mf">1.</span><span class="n">exhume</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Really, the whole interface is probably just messsing with forces we don’t understand.</p>

<p>For example, you probably don’t understand why <code>exhume</code> uses a <code>&amp;[u8]</code> when we said up above that we were going to use <code>&amp;mut [u8]</code>. In retrospect, there were warning signs that something was wrong.</p>

<h2 id="late-in-the-lab-one-night-">Late in the lab one night …</h2>

<p>Some drinks in, an ambitious scientist finds she needs to serialize a <code>&amp;[Vec&lt;Vec&lt;u64&gt;&gt;]</code>. She thinks:</p>

<blockquote>
  <p>Hey, couldn’t I implement <code>Abomonation</code> for <code>Vec&lt;T&gt;</code> where <code>T: Abomonation</code>?</p>
</blockquote>

<p>Well, you can certainly type it.</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Abomonation</span> <span class="k">for</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">where</span> <span class="n">T</span><span class="o">:</span> <span class="n">Abomonation</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">entomb</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span> <span class="n">writer</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write out the contents of self</span>
    <span class="p">}</span>
    <span class="k">unsafe</span> <span class="k">fn</span> <span class="n">exhume</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">,</span> <span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// read back the contents into &amp;mut self</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>You know, this might just work. A <code>Vec</code> is a pointer, a length, and a capacity. Three <code>usize</code> values. Serializing this triple doesn’t serialize the <code>Vec</code>’s <em>contents</em>, but we can just do that in <code>Vec</code>’s <code>entomb</code>. Similarly, when we pick up the serialized form of the <code>Vec</code>, a triple, it doesn’t point at anything valid (to our great shame, it points at some location in memory wherever we serialized this), but  <code>exhume</code> gives us a chance to read valid data back and make things right.</p>

<p>If the scientist did something responsible in <code>exhume</code>, like create a new <code>Vec&lt;T&gt;</code> with new backing memory and assign it to <code>*self</code>, the story ends happily. But our story doesn’t follow that path.</p>

<h2 id="writing-the-code-that-shouldnt-be-written">Writing the code that shouldn’t be written</h2>

<p>The scientist, unfortunately, was mad with power. She demanded <em>zero</em> allocations. She would use the binary data <em>as provided</em> to back her creepy, hard-to-reason-about deserialization machinations.</p>

<p>Rust provides unsafe functions capable of assembling a <code>Vec</code> out of “raw parts”: a pointer, a length, and a capacity. Our scientist is going to connect wires not meant to be connected, by building a <code>Vec</code> using a pointer into the supplied byte array.</p>

<p>Now, our scientist may be power-mad, but she is still a scientist so she’s going to do this properly.</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">unsafe</span> <span class="k">fn</span> <span class="n">exhume</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="bp">self</span><span class="p">,</span> <span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="o">&amp;</span><span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// 1. extract the memory from bytes to back our vector</span>
    <span class="kd">let</span> <span class="n">binary_len</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="o">*</span> <span class="n">mem</span><span class="o">::</span><span class="n">size_of</span><span class="o">::&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="kd">let</span> <span class="n">buffer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="p">[..</span><span class="n">binary_len</span><span class="p">];</span>
    <span class="o">*</span><span class="n">bytes</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bytes</span><span class="p">[</span><span class="n">binary_len</span><span class="p">..];</span>

    <span class="c1">// 2. transmute buffer to &amp;mut [u8], and then to a &amp;mut [T].</span>
    <span class="kd">let</span> <span class="n">slice</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="n">T</span><span class="p">]</span> <span class="o">=</span> <span class="n">bytes_to_typed</span><span class="p">(</span><span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>

    <span class="c1">// 3. build a new vector using this memory</span>
    <span class="kd">let</span> <span class="n">vector</span> <span class="o">=</span> <span class="n">Vec</span><span class="o">::</span><span class="n">from_raw_parts</span><span class="p">(</span><span class="n">slice</span><span class="p">.</span><span class="n">as_mut_ptr</span><span class="p">(),</span> <span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="p">(),</span> <span class="bp">self</span><span class="p">.</span><span class="n">len</span><span class="p">());</span>

    <span class="c1">// 4. overwrite *self w/o dropping it.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ptr</span><span class="o">::</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vector</span><span class="p">);</span>

    <span class="c1">// 5. pretend everything is normal; call exhume on each element</span>
    <span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">iter_mut</span><span class="p">()</span> <span class="p">{</span> <span class="n">element</span><span class="p">.</span><span class="n">exhume</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>Pretty much all of these lines (everything except step <code>1.</code>) are unsafe. Because the method has the <code>unsafe</code> tag, we don’t need to flag individual regions as unsafe. They are all <em>quite</em> unsafe.</p>

<p>Well, what could go wrong, really?</p>

<h2 id="graaaaaaaaarrrrr">GRAAAAAAAAARRRRR!!</h2>

<p>You know, actually it all sort of works.</p>

<h2 id="graaaaaaoooo">GRAAAaaaoooo?</h2>

<p>Yeah, there is a disasterous mess of things here, and really Rust’s memory safety isn’t touching any of this with a ten foot lifetime bound. But let’s talk about the possible issues.</p>

<p>First, let’s be clear that <code>exhume</code> is <code>unsafe</code>. Don’t call it. I haven’t figured out how to keep people from calling it yet (public traits export all their methods), but just don’t. It makes a few assumptions about how it will be called. It assumes that:</p>

<ol>
  <li>
    <p>The <code>&amp;[u8]</code> data is, in fact, exclusively held. We go and transmute it to <code>&amp;mut [u8]</code> which is very wrong unless we are sure that we have the only reference. Fortunately, <code>decode</code> takes a <code>&amp;mut [u8]</code> as its argument, and this ensures that our references are exclusive. We are also careful to partition the <code>&amp;[u8]</code> into disjoint parts when we use it, to maintain this invariant.</p>
  </li>
  <li>
    <p>The <code>&amp;mut self</code> parameter to <code>exhume</code> will not be dropped. It is important that we not drop the <code>Vec</code>, as that will attempt to release the backing memory, which … well it isn’t going to work out. Making a fake <code>Vec</code> that points somewhere in memory is ok as long as it is a fake <code>Vec</code>.</p>
  </li>
  <li>
    <p>The <code>&amp;mut self</code> parameter to <code>exhume</code> will only be presented outwards as a <code>&amp;self</code>. We can’t let anyone mutate or own this data. Trying to add elements to <code>Vec</code> will trigger a re-alloction, which would attempt to release the memory. The <code>Vec</code> needs to go away quietly once it has been used.</p>
  </li>
</ol>

<p>There are probably some other assumptions. Everything breaks if you pass in invalid data, for example. Don’t do that either.</p>

<p>In fact, sorting out whether these assumptions are properly nailed down, or whether something truly horrible has happened, is basically what I’m up to now. I don’t really know, and it isn’t particularly clear what I need to do to use <code>unsafe</code> correctly. I invite your thoughts and criticism.</p>

<p>Rust’s position is, perhaps refreshingly honestly: “yeah, it’s unsafe. you even said so.”</p>

<h2 id="epilogue">Epilogue</h2>

<p>What about our ambitious, power-mad scientist; where did she get off to?</p>

<p>While we have been fretting about what might have gone wrong, she is experiencing excellent throughput numbers. Let’s look at a few using Rust’s benchmarking facilities.</p>

<h3 id="encoding">Encoding</h3>

<p>Here is a helpful routine to spin Rust’s <code>Bencher</code> struct on any type implementing <code>Abomonation</code>.</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">_bench_enc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Abomonation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bencher</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Bencher</span><span class="p">,</span> <span class="n">vector</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">Vec</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="n">encode</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="n">bencher</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="k">as</span> <span class="kt">u64</span><span class="p">;</span>
    <span class="n">bencher</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span> <span class="p">{</span>
        <span class="n">bytes</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">encode</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span></code></pre></div>

<p>We try it out with types <code>Vec&lt;u64&gt;</code>, <code>Vec&lt;String&gt;</code>, and <code>Vec&lt;Vec&lt;(u64, String)&gt;&gt;</code> and see:</p>

<pre><code>test bench_enc_u64     ... bench:       411 ns/iter (+/- 84) = 19990 MB/s
test bench_enc_string  ... bench:     12039 ns/iter (+/- 3330) = 2893 MB/s
test bench_enc_vec_u_s ... bench:     12578 ns/iter (+/- 1665) = 3482 MB/s
</code></pre>

<p>The <code>String</code> is just <code>format!("grawwwwrr!")</code>. Results may vary with the string’s length, silliness.</p>

<p>I should also point out that the throughput is not <em>goodput</em>. It includes the extra pointers and capacities and stuff we didn’t need to send. The numbers do get a bit worse, especially for short strings. It’s the sort of thing you could fix by having a buffer implement <code>encode</code>/<code>decode</code> and push/pull just lengths. However, you do need to stage the <code>Vec</code>s somewhere, and our approach let <code>bytes</code> do that for us.</p>

<h3 id="decoding">Decoding</h3>

<p>What about deserialization? That is where all the mess is, right? Well, it is a bit hard to measure deserialization speed fairly, because we are really not doing much other than fixing up some pointers.</p>

<p>I did put some testing code in place to make sure that we were getting the right results back:</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">fn</span> <span class="n">_bench_dec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Abomonation</span><span class="o">+</span><span class="nb">Eq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bencher</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Bencher</span><span class="p">,</span> <span class="n">vector</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>

    <span class="kd">let</span> <span class="k">mut</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">Vec</span><span class="o">::</span><span class="n">new</span><span class="p">();</span>
    <span class="n">encode</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bytes</span><span class="p">);</span>
    <span class="n">bencher</span><span class="p">.</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="k">as</span> <span class="kt">u64</span><span class="p">;</span>
    <span class="n">bencher</span><span class="p">.</span><span class="n">iter</span><span class="p">(</span><span class="o">||</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">decode</span><span class="o">::&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">bytes</span><span class="p">[..]);</span>
        <span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="o">==</span> <span class="n">vector</span><span class="p">.</span><span class="n">len</span><span class="p">());</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mf">0.</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">assert</span><span class="o">!</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">vector</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span></code></pre></div>

<p>These give pretty comparable results. Apparently pushing a bunch of bytes works at about the same rate as checking that those bytes are what you expected. Again, not goodput numbers; <em>caveat emptor</em>.</p>

<pre><code>test bench_dec_u64     ... bench:       525 ns/iter (+/- 262) = 15649 MB/s
test bench_dec_string  ... bench:     11289 ns/iter (+/- 2432) = 3086 MB/s
test bench_dec_vec_u_s ... bench:     12557 ns/iter (+/- 2183) = 3488 MB/s
</code></pre>

<p>Just show how silly things are, here are the numbers where we comment out the assert loop, just checking the resulting lengths.</p>

<pre><code>test bench_dec_u64     ... bench:         2 ns/iter (+/- 0) = 4108000 MB/s
test bench_dec_string  ... bench:      2625 ns/iter (+/- 1031) = 13272 MB/s
test bench_dec_vec_u_s ... bench:      3020 ns/iter (+/- 1266) = 14503 MB/s
</code></pre>

<p>Hey look, 4TB/s deserialization. Maybe it is time to head back to Silicon Valley, maybe start things up.</p>

<h2 id="appendix-encode-and-decode">Appendix: encode and decode</h2>

<p>I wanted to put the implementations up here, but they aren’t very pretty. In particular, I suspect they could be greatly improved (possibly by deletion).</p>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="n">encode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Abomonation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">typed</span><span class="o">:</span> <span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="n">slice</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">slice</span><span class="o">::</span><span class="n">from_raw_parts</span><span class="p">(</span><span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">typed</span><span class="p">),</span> <span class="n">size_of</span><span class="o">::&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">())</span> <span class="p">};</span>
    <span class="n">bytes</span><span class="p">.</span><span class="n">write_all</span><span class="p">(</span><span class="n">slice</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="n">typed</span><span class="p">.</span><span class="n">entomb</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="k">pub</span> <span class="k">fn</span> <span class="n">decode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">:</span> <span class="n">Abomonation</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bytes</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="kt">u8</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="o">&amp;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="p">(</span><span class="n">split1</span><span class="p">,</span> <span class="n">split2</span><span class="p">)</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">.</span><span class="n">split_at_mut</span><span class="p">(</span><span class="n">mem</span><span class="o">::</span><span class="n">size_of</span><span class="o">::&lt;</span><span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">());</span>
    <span class="kd">let</span> <span class="n">result</span><span class="o">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">unsafe</span> <span class="p">{</span> <span class="n">mem</span><span class="o">::</span><span class="n">transmute</span><span class="p">(</span><span class="n">split1</span><span class="p">.</span><span class="n">get_unchecked_mut</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">};</span>
    <span class="k">unsafe</span> <span class="p">{</span> <span class="n">result</span><span class="p">.</span><span class="n">exhume</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="o">&amp;*</span><span class="n">split2</span><span class="p">);</span> <span class="p">}</span>
    <span class="n">result</span>
<span class="p">}</span></code></pre></div>

<p>The whole pile of stuff will be up on <a href="https://github.com/frankmcsherry">github</a> and <a href="https://crates.io">crates.io</a> eventually, but I wanted to take at least a bit of time with other eyeballs on this to see if a) it is all horribly wrong, and b) whether the risk is ever worth it.</p>

<p>Also, I should obviously avoid serializing pointers to your memory locations. No one needs to see that.</p>

  </article>

</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Frank McSherry</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Frank McSherry</li>
          <li><a href="mailto:mcsherry@gmail.com">mcsherry@gmail.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/frankmcsherry">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">frankmcsherry</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/frankmcsherry">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">frankmcsherry</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">Some notes on doing less of what I used to do, and more of what I'd rather be doing.</p>
      </div>
    </div>

  </div>

</footer>



  </body>

</html>
